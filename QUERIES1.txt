select * from customers312;
select * from employees312;
select * from locations312;
select * from categories312;
select * from excursions312;
select * from transportation312;
select * from accommodation312;
select * from reservations312;



--LIST RECORDS IN HIERARCHICAL ORDER 

SELECT LEVEL, LPAD(' ',2*(LEVEL - 1), '*') || full_name "Employee",
       empl_code, manager
FROM employees312
START WITH manager IS NULL
CONNECT BY PRIOR empl_code = manager
ORDER BY 1;


--DISPLAY EMPLOYEE ID, FULL NAME, MANAGER ID, SALARY AND HIREDATE OF EMPLOYEES WHO DO NOT MANAGE ANYONE BY USING A CORRELATED SUBQUERY

SELECT empl_code, full_name, manager, salary, hiredate 
FROM employees312 e
WHERE NOT EXISTS 
(SELECT empl_code FROM employees312 e1 WHERE e.empl_code = e1.manager);


--DISPLAY EMPLOYEE CODE, FULL NAME, SALARY, MANAGER, HIREDATE AND NUMBER OF EXCURSIONS, LED BY EMPLOYEES WHO WERE HIRED BEFORE THEIR MANAGERS
  ON THE FOURTH DAY OF THE MONTH.

select a.Empl_Code, a.Full_Name, a.Salary, a.Manager, a.Hiredate, (select count(ex.Excursion_Code) from Excursions312 ex where a.Empl_Code=ex.Empl_Code)
from Employees312 a, Employees312 b 
where a.Hiredate<b.Hiredate
and to_char(a.Hiredate, 'DD')='04'
group by a.Empl_Code, a.Full_Name, a.Salary, a.Manager, a.Hiredate
order by 1;


--DISPLAY EMPLOYEE'S CODE, FULL NAME AND THE CODE OF THE EXCURSIONS THEY LED, WHO HAD MORE THAN 8 RESERVATIONS MADE UNDER.

select e.empl_code, e.full_name, dd.excursion_code
from employees312 e join 
(
select ex.empl_code, ex.excursion_code, ex.trip_reservations
from employees312 e join excursions312 ex
on e.empl_code = ex.empl_code
where ex.trip_reservations>8
) dd
on e.empl_code = dd.empl_code
order by 1;


--PRODUCE A REPORT WITH THE FOLLOWING STRUCTURE: CUSTOMER CODE, TITLE, FULL NAME, TRANSPORTATION MEAN, TRANSPORTATION CLASS, NUMBER OF RESERVED EXCURSIONS MADE
IN 2016, 2017, 2018.
THE REPORT SHOULD CONTAIN INFORMATION ONLY FOR CUSTOMERS WITH ID HIGHER THAN _005 AND LOWER THAN _025, WHO ARE FEMALES.

TRANSPORTATION CLASS SHOULD HAVE THE FOLLOWING STRUCTURE:
Economy_Class     'Included in the initial price.'
Business_Class    'Charged 30$ extra.'
                  'Unspecified'

Note: If some information is missing, you should replace nulls with appropriate values.


drop table temporary_customer;
select * from temporary_customer;

create table temporary_customer as
(
select c.customer_code, c.title, c.full_name, 
c.transportation_mean, 
case t.transportation_class
when 'Economy_Class' then 'Included in the initial price.'
when 'Business_Class' then 'Charged 30$ extra.'
else 'Unspecified'
end trans_class
from customers312 c join transportation312 t 
on c.transportation_mean=t.transportation_mean
where c.customer_code between 'Cust_005' and 'Cust_025' and
c.gender='Female');


drop table temp_counting;
select * from temp_counting;

create table temp_counting as
(
select customer_code, 
sum(decode(to_char(reservation_date, 'YYYY'), '2016', 1,0)) counting_2016,
sum(decode(to_char(reservation_date, 'YYYY'), '2017', 1,0)) counting_2017,
sum(decode(to_char(reservation_date, 'YYYY'), '2018', 1,0)) counting_2018
from excursions312
group by customer_code
);

select c.customer_code, c.title, c.full_name, c.transportation_mean, c.trans_class,
nvl(t.counting_2016,0) "Reserved Excursions 2016", 
nvl(t.counting_2017,0) "Reserved Excursions 2017", 
nvl(t.counting_2018,0) "Reserved Excursions 2018"
from temporary_customer c join temp_counting t
on c.customer_code=t.customer_code
order by 1;



--CREATE A FUNCTION THAT RETURNS THE REVENUE GENERATED BY THE EXCURSIONS ORDERED IN EACH CATEGORY.

--VIEW

select * from Excursions_v1;

create or replace view Excursions_v1 as
select b.Category_Number, b.Type, sum(((substr(b.Duration,1,1)*c.Price_Per_Day*d.Trip_Reservations)+f.Extra_Price+h.Extra_Price1)) as "REVENUE" 
from Categories312 b join Locations312 c on b.Category_Number=c.Category_Number join Excursions312 d on c.Location_Code=d.Location_Code
join Customers312 e on d.Customer_Code=e.Customer_Code join Transportation312 f on e.Transportation_Mean=f.Transportation_Mean
join Reservations312 g on e.Customer_Code=g.Customer_Code join Accommodation312 h on g.Accommodation_Type=h.Accommodation_Type
group by b.Category_Number,b.Type
order by 3 desc;

select * from Excursions_v2;

create or replace view Excursions_v2 as
(select c.classification, (c.expertise_price+c.insurance_price+c.membership_price) "PACKAGES_PRICES"
from packages312 c); 


select g.customer_code, count(decode(h.classification,'Regular',g.Acq_Num)) as "Regular",
count(decode(h.classification,'VIP',g.Acq_Num)) as "VIP",
count(decode(h.classification,'Premium',g.Acq_Num)) as "Premium"
from Package_Acq312 g, Packages312 h
where g.classification=h.classification
group by g.customer_code
order by 1;

--FUNCTION
create or replace function Revenue_Check(categ excursions_v1.category_number%type)
return Excursions_v1.revenue%type is
v_rev Excursions_v1.revenue%type;
begin
select revenue
into v_rev
from Excursions_v1
where category_number=categ;

return(v_rev);

end;

--RETRIEVE THE FUNCTION

declare
v number;
begin 
v:=revenue_check('Category_1');
dbms_output.put_line(v);
end;

--ASSUMING THAT THE COMMISSION RATE OF EMPLOYEES IS 14%, CREATE A PROCEDURE THAT CALCULATES THE TOTAL COMMISSION RATE OF EMPLOYEES PER EACH CATEGORY. 

CREATE OR REPLACE PROCEDURE CAT_COMMISSION(categ excursions_v1.category_number%type)
is
v_com Excursions_v1.revenue%type;
begin
select revenue*0.14
into v_com
from Excursions_v1
where category_number=categ;

dbms_output.put_line('The employee commission generated per each excursion category is ' || v_com);
end;

begin
cat_commission('Category_1');
end;


--CREATE A FUNCTION THAT RETURNS THE CATEGORY OF THE EXCURSION WHEN GIVEN AS ARGUMENTS THE EXCURSION ID AND LOCATION WHERE IT TOOK PLACE

create or replace function getCategory(ex_id excursions312.excursion_code%type, loc_code excursions312.location_code%type)
return locations312.category_number%type
is
categ varchar2(20);
begin
select category_number
into categ
from  locations312 l join excursions312 ex
on l.location_code= ex.location_code
where ex.excursion_code=ex_id and ex.location_code=loc_code;

return(categ);
end;

--RETRIEVE IT

declare
v varchar2(20);
begin 
v:=getCategory('Excursion_007','Location_001');
dbms_output.put_line(v);
end;


--CREATE A TRIGGER THAT WHEN INSERTING ACCOMMODATION TYPES AND FACILITIES IN THE ACCOMMODATION312 TABLE WILL SUBSTITUTE POTENTIAL SPACES WITH '-'.
  IF THE USER DECIDES TO UPDATE THE FIELDS IN THIS TABLE AN ERROR MESSAGE SHOULD BE DISPLAYED TO HIM.

CREATE OR REPLACE TRIGGER accommodation_insert
  BEFORE INSERT OR UPDATE OF accommodation_type, facilities ON accommodation312
  FOR EACH ROW
  WHEN (REGEXP_LIKE(new.accommodation_type,' ') or REGEXP_LIKE(new.facilities,' '))
BEGIN
  IF INSERTING THEN
    :new.accommodation_type := 
      REGEXP_REPLACE(:new.accommodation_type,' ','-',1);
   
    :new.facilities:= 
      REGEXP_REPLACE(:new.facilities,' ','-',1);

  ELSIF UPDATING THEN
    IF REGEXP_LIKE(:new.accommodation_type,' ') THEN
      RAISE_APPLICATION_ERROR(-20099,'Updates can''t use multiple names for accommodation types.'); 
    ELSIF REGEXP_LIKE(:new.facilities,' ') THEN
      RAISE_APPLICATION_ERROR(-20099,'Updates can''t use multiple names for facility types.'); 
    END IF;
  END IF;
END accommodation_insert;

--INSERT STATEMENTS TO PROVE THE ENFORCEMENT OF THE TRIGGER

INSERT INTO accommodation312
( accommodation_type
, facilities
, included_in_initial_price
, extra_price1
)
VALUES
( 'Cottage Y Y'
, 'House Keeper'
, 'No'
, 20
);

--UPDATE STATEMENT TO PROVE THE ENFORCEMENT OF THE TRIGGER

update accommodation312
set accommodation_type='Cottage Y Y', facilities='House Keeper'
where accommodation_type='Cottage-Y-Y' and facilities='House-Keeper';

--DELETE THE ROW INSERTED TO UNDO THE INSERTION

delete from accommodation312
where accommodation_type='Cottage-Y-Y' and facilities='House-Keeper';



--USE A CURSOR TO RETRIEVE THE EMPLOYEE CODE AND NAME FROM THE EMPLOYEES312. PASS THE EMPLOYEE CODE TO ANOTHER CURSOR TO RETRIEVE FROM THE EXCURSIONS312 TABLE
THE DETAILS OF THE EXCURSIONS THAT THEY HAVE MANAGED.

DECLARE
CURSOR C_EMPL IS 
   SELECT empl_code, full_name
   FROM employees312;
lv_empl employees312.empl_code%TYPE;
lv_name employees312.full_name%TYPE;

CURSOR C_EXC IS 
   SELECT excursion_code, reservation_date
   FROM excursions312
   WHERE empl_code= lv_empl
   ORDER BY excursion_code;

lv_exc_code excursions312.excursion_code%TYPE;
lv_res excursions312.reservation_date%TYPE;

BEGIN
OPEN c_empl;
LOOP
FETCH c_empl INTO lv_empl, lv_name;
IF c_empl%NOTFOUND
THEN
EXIT;
END IF;
Dbms_output.put_line('Employee Code: '||lv_empl||' Employee Name : '||lv_name);
   OPEN C_EXC;
   LOOP
   FETCH C_EXC INTO lv_exc_code, lv_res;
   IF C_EXC%NOTFOUND
   THEN
   EXIT;
   END IF;
   Dbms_output.put_line('          Excursion Code : '||lv_exc_code||'  Reservation Date : '||lv_res);
   END LOOP;
   CLOSE c_exc;
   Dbms_output.put_line(' ');
END LOOP;
Dbms_output.put_line('Total rows fetched is '||c_empl%ROWCOUNT);
CLOSE c_empl;
END;

